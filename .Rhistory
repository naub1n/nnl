#'
#' @importFrom raster compareCRS
#'
#' @export
#'
#' @examples
nnl <- function(l_A, l_B, id_l_A, id_l_B, id_p_A = "ID_PTS_A", id_p_B = "ID_PTS_B", step = 5, rate = 45, p = T, ncores = NULL){
#test CRS comparaison
if(!raster::compareCRS(l_A, l_B)) stop("SpatialPointsDataFrames have not the same CRS")
#test projection info. objects should be in planar coordinates (cf sp::sample)
if(!is.projected(l_A) || !is.projected(l_B)) stop("objects should be in planar coordinates")
#create points along lines A
points_A <- create_pts(l = l_A, id_l = id_l_A, id_p = id_p_A, step = step, p = p, ncores = ncores)
#create points along lines B
points_B <- create_pts(l = l_B, id_l = id_l_B, id_p = id_p_B, step = step, p = p, ncores = ncores)
#find nearest points
np_points_A <- find_np(pts_A = points_A, pts_B = points_B , id_p_A = id_p_A, id_p_B = id_p_B, p = p, ncores = ncores)
#select nearest lines
np_step1 <- nnl_step1(pts_A = points_A,
pts_B = points_B,
fnp_A = np_points_A,
id_p_A = id_p_A,
id_p_B = id_p_B,
id_l_A = id_l_A,
id_l_B = id_l_B,
rate = rate)
#find discontinuities
np_step2 <- nnl_step2(l_B = l_B, r_s1_A = np_step1, id_l_B = id_l_B,id_l_A = id_l_A)
#select only columns with IDs of lines A and B on step 1
nnl_s1 <- np_step1[, c(id_l_A, id_l_B)]
#Idem on step 2
nnl_s2 <- np_step2[, c(id_l_A, id_l_B)]
#fuse dataframes
nnl_full <- rbind(nnl_s1, nnl_s2)
#Select nearest lines in lines B
nnl_sldf <- l_B[l_B@data[, id_l_B] %in% nnl_full[, id_l_B],]
#add lines A IDs to nearest lines B
nnl_sldf <- merge(nnl_sldf, nnl_full, by = id_l_B, all.x = T)
#return Spatial
return(nnl_sldf)
}
extrapolate_example <- nnl(l_A = example,
l_B = river_bresle,
id_l_A = "ID_EXAMPLE",
id_l_B = "CdEntiteHydrographique")
example <- sp::spTransform(example, CRS("+init=epsg:4326"))
extrapolate_example <- nnl(l_A = example,
l_B = river_bresle,
id_l_A = "ID_EXAMPLE",
id_l_B = "CdEntiteHydrographique")
river_bresle <- sp::spTransform(river_bresle, CRS("+init=epsg:2154"))
river_bresle <- sp::spTransform(river_bresle, CRS("+init=epsg:2154"))
extrapolate_example <- nnl(l_A = example,
l_B = river_bresle,
id_l_A = "ID_EXAMPLE",
id_l_B = "CdEntiteHydrographique")
example <- readOGR("https://raw.githubusercontent.com/naub1n/nnl/master/example/example.geojson")
extrapolate_example <- nnl(l_A = example,
l_B = river_bresle,
id_l_A = "ID_EXAMPLE",
id_l_B = "CdEntiteHydrographique")
pts_A <- create_pts(example, id_l = "ID_EXAMPLE")
pts_B <- create_pts(l = river_bresle, id_l = "CdEntiteHydrographique", p = F)
l_A = example
l_B = river_bresle
id_l_A = "ID_EXAMPLE"
id_l_B = "CdEntiteHydrographique"
#create points along lines A
points_A <- create_pts(l = l_A, id_l = id_l_A, id_p = id_p_A, step = step, p = p, ncores = ncores)
step = 5
rate = 45
p = T
ncores = NULL
id_p_A = "ID_PTS_A"
id_p_B = "ID_PTS_B"
#find nearest points
np_points_A <- find_np(pts_A = points_A, pts_B = points_B , id_p_A = id_p_A, id_p_B = id_p_B, p = p, ncores = ncores)
#create points along lines A
points_A <- create_pts(l = l_A, id_l = id_l_A, id_p = id_p_A, step = step, p = p, ncores = ncores)
#create points along lines B
points_B <- create_pts(l = l_B, id_l = id_l_B, id_p = id_p_B, step = step, p = p, ncores = ncores)
#find nearest points
np_points_A <- find_np(pts_A = points_A, pts_B = points_B , id_p_A = id_p_A, id_p_B = id_p_B, p = p, ncores = ncores)
#select nearest lines
np_step1 <- nnl_step1(pts_A = points_A,
pts_B = points_B,
fnp_A = np_points_A,
id_p_A = id_p_A,
id_p_B = id_p_B,
id_l_A = id_l_A,
id_l_B = id_l_B,
rate = rate)
#find discontinuities
np_step2 <- nnl_step2(l_B = l_B, r_s1_A = np_step1, id_l_B = id_l_B,id_l_A = id_l_A)
r_s1_A = np_step1
#extract points coordinates of each line
lst_coord <- lapply(slot(l_B, "lines"), function(x) lapply(slot(x, "Lines"), function(y) slot(y, "coords")))
#create IDs vector
nodes <- subset(l_B@data, select = id_l_B)
#extract extremities coordinates of each lines
nodes$X_MIN <- as.numeric(lapply(lst_coord, function(x) x[[1]][1,1]))
nodes$Y_MIN <- as.numeric(lapply(lst_coord, function(x) x[[1]][1,2]))
nodes$X_MAX <- as.numeric(lapply(lst_coord, function(x) x[[length(x)]][nrow(x[[length(x)]]),1]))
nodes$Y_MAX <- as.numeric(lapply(lst_coord, function(x) x[[length(x)]][nrow(x[[length(x)]]),2]))
#create dataframe with lower extremities
nodes_min <- subset(nodes, select=c("ID","X_MIN","Y_MIN"))
View(nodes)
#create dataframe with lower extremities
nodes_min <- subset(nodes, select=c(id_l_B, "X_MIN", "Y_MIN"))
#create dataframe with upper extremities
nodes_max <- subset(nodes,select=c(id_l_B, "X_MAX", "Y_MAX"))
#rename columns
colnames(nodes_min)[2:3]<-c("X","Y")
colnames(nodes_max)[2:3]<-c("X","Y")
#merge dataframes
nodes.full <- rbind(nodes_min,nodes_max)
#add ID for each node
nodes.full$ID_NODE <- seq.int(nrow(nodes.full))
#Jointure permettant de distinguer les tronçons identifiés sur le DP en phase 1
nodes.nnlstep1 <- merge(nodes.full, r_s1_A, by = id_l_B, all.x = T, all.y = T)
#Remplace les valeurs nulles du champ DP_phase1 par "non" // ATTENTION : as.character devant lapply, sinon le champs est de type list et ça bug dans les calcul de somme
nodes.nnlstep1$SELECT_STEP1 <- as.character(lapply(nodes.nnlstep1$SELECT_STEP1,function(x) ifelse (is.na(x),FALSE,x)))
#Toilettage table jointure
nodes.nnlstep1 <- subset(nodes.nnlstep1, select=c(id_l_A, id_l_B, "ID_NODE","X","Y","SELECT_STEP1"))
#merge nodes with themselves to find neighbour of each line
RQT1 <- merge(nodes.nnlstep1, nodes.nnlstep1, by=c("X","Y"))
#exclude pairs with the same line ID
RQT1 <- subset(RQT1, RQT1$ID.x != RQT1$ID.y)
#count number of lines selected in nnl_step1 for each node
RQT2 <- plyr::ddply(RQT1,
c(paste0(id_l_A,".x"), paste0(id_l_B,".x"), "ID_NODE.x", "SELECT_STEP1.x"),
.fun = function(x, colname) plyr::summarise(x, NB_LINE_SELECT_STEP1 = sum(x[,colname] == TRUE)),
colname = "SELECT_STEP1.y")
RQT3<-plyr::ddply(RQT2,c(paste0(id_l_A,".x"), paste0(id_l_B,".x"), "SELECT_STEP1.x"),
.fun = function(x) plyr::summarise(x,
#number of nodes
NB_NODES = length(x[,"ID_NODE.x"]),
#standard deviation of number of points for each extremity
SD_LINES_SELECTED = stats::sd(x[, "NB_LINE_SELECT_STEP1"]),
#Mean of number of points for each extremity
MEAN_LINES_SELECTED = mean(x[, "NB_LINE_SELECT_STEP1"])
))
# create classes
RQT3$classe<-ifelse(RQT3$NB_NODES == 2 & RQT3$MEAN_LINES_SELECTED == 0.5 & RQT3$SD_LINES_SELECTED == stats::sd(c(1,2)),"1.0",
ifelse(RQT3$NB_NODES == 2 & RQT3$MEAN_LINES_SELECTED == 1 & RQT3$SD_LINES_SELECTED == 0,"1.1",
ifelse(RQT3$NB_NODES == 2 & RQT3$MEAN_LINES_SELECTED == 1 & RQT3$SD_LINES_SELECTED == 1,"2.0",
ifelse (RQT3$NB_NODES == 2 & RQT3$MEAN_LINES_SELECTED == 1.5 & RQT3$SD_LINES_SELECTED == stats::sd(c(1,2)),"2.1",
ifelse (RQT3$NB_NODES == 2 & RQT3$MEAN_LINES_SELECTED == 2 & RQT3$SD_LINES_SELECTED == 0,"2.2",
"OTHER")))))
#identify discontinuities
RQT3$Disc<-ifelse(
#lines not selected at origin
RQT3$SELECT_STEP1.x == FALSE &
#wich have one line at each extremity (so 2 lines)
RQT3$NB_NODES == 2 &
#where there are as many lines at each extremity
RQT3$SD_LINES_SELECTED == 0 &
#to select only in case where there are 1 line selected at extremity and 1 line selected at other extremity
RQT3$MEAN_LINES_SELECTED == 1
,TRUE,FALSE)
#select only discontinuities
disc <- subset(RQT3, RQT3$Disc == TRUE)
#rename columns
colnames(disc)[grep(paste0(id_l_A,".x"), colnames(disc))] <- id_l_A
colnames(disc)[grep(paste0(id_l_B,".x"), colnames(disc))] <- id_l_B
#find line A ID for each line B
disc[, id_l_A] <- apply(disc, 1, function(x) {
id <- unique(RQT1[RQT1[,"ID.x"] == x[id_l_B] & RQT1$SELECT_STEP1.y == TRUE , "CdMasseDEa.y"])
#return NA if many IDs are found
id.f <- if(length(id) == 1) id else NA
return(id.f)
})
#find line A ID for each line B
disc[, id_l_A] <- apply(disc, 1, function(x) {
id <- unique(RQT1[RQT1[, paste0(id_l_B, ".x")] == x[id_l_B] & RQT1$SELECT_STEP1.y == TRUE , "CdMasseDEa.y"])
#return NA if many IDs are found
id.f <- if(length(id) == 1) id else NA
return(id.f)
})
#'
#' @return a data.frame. Contains discontinuities.
#'
#' @importFrom stats sd
#' @importFrom plyr ddply
#' @importFrom plyr summarise
#'
#' @export
#'
#' @examples
nnl_step2 <- function(l_B, r_s1_A, id_l_A, id_l_B){
#extract points coordinates of each line
lst_coord <- lapply(slot(l_B, "lines"), function(x) lapply(slot(x, "Lines"), function(y) slot(y, "coords")))
#create IDs vector
nodes <- subset(l_B@data, select = id_l_B)
#extract extremities coordinates of each lines
nodes$X_MIN <- as.numeric(lapply(lst_coord, function(x) x[[1]][1,1]))
nodes$Y_MIN <- as.numeric(lapply(lst_coord, function(x) x[[1]][1,2]))
nodes$X_MAX <- as.numeric(lapply(lst_coord, function(x) x[[length(x)]][nrow(x[[length(x)]]),1]))
nodes$Y_MAX <- as.numeric(lapply(lst_coord, function(x) x[[length(x)]][nrow(x[[length(x)]]),2]))
#create dataframe with lower extremities
nodes_min <- subset(nodes, select=c(id_l_B, "X_MIN", "Y_MIN"))
#create dataframe with upper extremities
nodes_max <- subset(nodes,select=c(id_l_B, "X_MAX", "Y_MAX"))
#rename columns
colnames(nodes_min)[2:3]<-c("X","Y")
colnames(nodes_max)[2:3]<-c("X","Y")
#merge dataframes
nodes.full <- rbind(nodes_min,nodes_max)
#add ID for each node
nodes.full$ID_NODE <- seq.int(nrow(nodes.full))
#Jointure permettant de distinguer les tronçons identifiés sur le DP en phase 1
nodes.nnlstep1 <- merge(nodes.full, r_s1_A, by = id_l_B, all.x = T, all.y = T)
#Remplace les valeurs nulles du champ DP_phase1 par "non" // ATTENTION : as.character devant lapply, sinon le champs est de type list et ça bug dans les calcul de somme
nodes.nnlstep1$SELECT_STEP1 <- as.character(lapply(nodes.nnlstep1$SELECT_STEP1,function(x) ifelse (is.na(x),FALSE,x)))
#Toilettage table jointure
nodes.nnlstep1 <- subset(nodes.nnlstep1, select=c(id_l_A, id_l_B, "ID_NODE","X","Y","SELECT_STEP1"))
#merge nodes with themselves to find neighbour of each line
RQT1 <- merge(nodes.nnlstep1, nodes.nnlstep1, by=c("X","Y"))
#exclude pairs with the same line ID
RQT1 <- subset(RQT1, RQT1$ID.x != RQT1$ID.y)
#count number of lines selected in nnl_step1 for each node
RQT2 <- plyr::ddply(RQT1,
c(paste0(id_l_A,".x"), paste0(id_l_B,".x"), "ID_NODE.x", "SELECT_STEP1.x"),
.fun = function(x, colname) plyr::summarise(x, NB_LINE_SELECT_STEP1 = sum(x[,colname] == TRUE)),
colname = "SELECT_STEP1.y")
#statistics of each line
# RQT3<-plyr::ddply(RQT2,c(paste0(id_l_A,".x"), paste0(id_l_B,".x"), "SELECT_STEP1.x"), plyr::summarise ,
#             #number of nodes
#             NB_NODES = length(ID_NODE.x),
#             #standard deviation of number of points for each extremity
#             SD_LINES_SELECTED = stats::sd(NB_LINE_SELECT_STEP1),
#             #Mean of number of points for each extremity
#             MEAN_LINES_SELECTED = mean(NB_LINE_SELECT_STEP1))
RQT3<-plyr::ddply(RQT2,c(paste0(id_l_A,".x"), paste0(id_l_B,".x"), "SELECT_STEP1.x"),
.fun = function(x) plyr::summarise(x,
#number of nodes
NB_NODES = length(x[,"ID_NODE.x"]),
#standard deviation of number of points for each extremity
SD_LINES_SELECTED = stats::sd(x[, "NB_LINE_SELECT_STEP1"]),
#Mean of number of points for each extremity
MEAN_LINES_SELECTED = mean(x[, "NB_LINE_SELECT_STEP1"])
))
# create classes
RQT3$classe<-ifelse(RQT3$NB_NODES == 2 & RQT3$MEAN_LINES_SELECTED == 0.5 & RQT3$SD_LINES_SELECTED == stats::sd(c(1,2)),"1.0",
ifelse(RQT3$NB_NODES == 2 & RQT3$MEAN_LINES_SELECTED == 1 & RQT3$SD_LINES_SELECTED == 0,"1.1",
ifelse(RQT3$NB_NODES == 2 & RQT3$MEAN_LINES_SELECTED == 1 & RQT3$SD_LINES_SELECTED == 1,"2.0",
ifelse (RQT3$NB_NODES == 2 & RQT3$MEAN_LINES_SELECTED == 1.5 & RQT3$SD_LINES_SELECTED == stats::sd(c(1,2)),"2.1",
ifelse (RQT3$NB_NODES == 2 & RQT3$MEAN_LINES_SELECTED == 2 & RQT3$SD_LINES_SELECTED == 0,"2.2",
"OTHER")))))
#identify discontinuities
RQT3$Disc<-ifelse(
#lines not selected at origin
RQT3$SELECT_STEP1.x == FALSE &
#wich have one line at each extremity (so 2 lines)
RQT3$NB_NODES == 2 &
#where there are as many lines at each extremity
RQT3$SD_LINES_SELECTED == 0 &
#to select only in case where there are 1 line selected at extremity and 1 line selected at other extremity
RQT3$MEAN_LINES_SELECTED == 1
,TRUE,FALSE)
#select only discontinuities
disc <- subset(RQT3, RQT3$Disc == TRUE)
#rename columns
colnames(disc)[grep(paste0(id_l_A,".x"), colnames(disc))] <- id_l_A
colnames(disc)[grep(paste0(id_l_B,".x"), colnames(disc))] <- id_l_B
#find line A ID for each line B
disc[, id_l_A] <- apply(disc, 1, function(x) {
id <- unique(RQT1[RQT1[, paste0(id_l_B, ".x")] == x[id_l_B] & RQT1$SELECT_STEP1.y == TRUE , "CdMasseDEa.y"])
#return NA if many IDs are found
id.f <- if(length(id) == 1) id else NA
return(id.f)
})
#return result
return(disc)
}
#find discontinuities
np_step2 <- nnl_step2(l_B = l_B, r_s1_A = np_step1, id_l_B = id_l_B, id_l_A = id_l_A)
#select only columns with IDs of lines A and B on step 1
nnl_s1 <- np_step1[, c(id_l_A, id_l_B)]
#Idem on step 2
nnl_s2 <- np_step2[, c(id_l_A, id_l_B)]
#fuse dataframes
nnl_full <- rbind(nnl_s1, nnl_s2)
#Select nearest lines in lines B
nnl_sldf <- l_B[l_B@data[, id_l_B] %in% nnl_full[, id_l_B],]
#add lines A IDs to nearest lines B
nnl_sldf <- merge(nnl_sldf, nnl_full, by = id_l_B, all.x = T)
library(nnl)
library(rgdal)
river_bresle <- readOGR("https://api.sandre.eaufrance.fr/coursdeau/v1/amont/G01-0400?pk_vid=aade75889c86a2471576396546bb9c85")
example <- readOGR("https://raw.githubusercontent.com/naub1n/nnl/master/example/example.geojson")
river_bresle <- sp::spTransform(river_bresle, CRS("+init=epsg:2154"))
extrapolate_example <- nnl(l_A = example,
l_B = river_bresle,
id_l_A = "ID_EXAMPLE",
id_l_B = "CdEntiteHydrographique")
plot(extrapolate_example )
plot(river_bresle, col = blue)
plot(river_bresle, col = "blue")
plot(example, col = "green", add = T)
plot(extrapolate_example, col = "red", add = T )
usethis::use_package('rgdal')
library(nnl)
l[[1]]
l[1]
l[1,]
l[1,]@lines
l@lines[1]
l@lines[1]@coords
l@lines[1]$coords
l@lines[[1]]$coords
l@lines[[1]]@coords
test=l@lines[[1]]
test@Lines$coords
View(test)
test@Lines
test2=test@Lines
test2=test@Lines[[1]]
View(test2)
test2@coords
res <- lapply(slot(l, "lines"), function(x) lapply(slot(x, "Lines"),
function(y) slot(y, "coords")))
View(res)
res[1]
test = res[1]
test = data.frame(res[1])
View(test)
test = lapply(res, function(x) {
df <- data.frame(res[1])})
View(test)
length(test)
for(i in 1:length(test)){
test[i, "ID_B"] <- l@data[i, id_l_B]
}
for(i in 1:length(test)){
test[i][, "ID_B"] <- l@data[i, id_l_B]
}
i=1
test[i][, "ID_B"]
test[i]
test[[i]]
test[[i]][, "ID_B"]
for(i in 1:length(test)){
test[[i]][, "ID_B"] <- l@data[i, id_l_B]
}
View(test)
l@data[i, id_l_B]
View(test[[i]])
View(res)
View(test[[2]])
l@data[i, id_l_B]
View(test)
test = lapply(res, function(x) {
df <- data.frame(x)})
for(i in 1:length(test)){
test[[i]][, "ID_B"] <- l@data[i, id_l_B]
}
View(test)
nrow(test[[1]])
test[[1]][i,c("X1","X2")]
i=1
test[[1]][i,c("X1","X2")]
Line(test[[1]][i,c("X1","X2")], test[[1]][i+1, c("X1","X2")])
est[[1]][i,c("X1","X2")]
test[[1]][i,c("X1","X2")]
test[[1]][i+1, c("X1","X2")]
Line(c(test[[1]][i,c("X1","X2")], test[[1]][i+1, c("X1","X2")]))
Line(test[[1]][i:i+1,c("X1","X2")])
test_ligne <- Line(test[[1]][i:i+1, c("X1","X2")])
plot(test_ligne)
test[[1]][i:i+1, c("X1","X2")]
test[[1]][i:2, c("X1","X2")]
test[[1]][i:(i+1), c("X1","X2")]
test_ligne <- Line(test[[1]][i:(i+1), c("X1","X2")])
plot(test_ligne)
l1a <- rbind(c(1, 3), c(2,2) ,c(3,2))
View(l1a)
test_ligne <- Line(as.matrix(test[[1]][i:(i+1), c("X1","X2")]))
as.matrix(test[[1]][i:(i+1), c("X1","X2")])
plot(test_ligne)
data.matrix(test[[1]][i:(i+1), c("X1","X2")])
test_ligne <- Line(data.matrix(test[[1]][i:(i+1), c("X1","X2")]))
test_ligne <- Line(as.matrix(test[[1]][i:(i+1), c("X1","X2")]))
s.vector(test[[1]][i:(i+1), c("X1","X2")])
as.vector(test[[1]][i:(i+1), c("X1","X2")])
lol <- c(1,2)
as.numeric(test[[1]][i:(i+1), c("X1","X2")])
unlist(test[[1]][i:(i+1), c("X1","X2")])
test_ligne <- Line(unlist(test[[1]][i:(i+1), c("X1","X2")]))
line_unique <- rbind(test[[1]][i:(i+1), c("X1","X2")])
test_ligne <- Line(line_unique)
plot(test_ligne)
test[[1]][i, "X1"]
line_unique <- rbind(c(test[[1]][i, "X1"], test[[1]][i, "X1"]), c(test[[1]][i+1, "X1"], test[[1]][i+1, "X1"])
test_ligne <- Line(line_unique)
}
line_unique <- rbind(c(test[[1]][i, "X1"], test[[1]][i, "X1"]), c(test[[1]][i+1, "X1"], test[[1]][i+1, "X1"]))
test_ligne <- Line(line_unique)
plot(test_ligne)
#add lines A IDs to nearest lines B
nnl_sldf <- merge(nnl_sldf, nnl_full, by = id_l_B, all.x = T)
LinesLength(nnl_sldf)
test = sapply(methods::slot(nnl_sldf,"lines"), function(x) sp::LinesLength(x))
sum(test)
test = sapply(methods::slot(example,"lines"), function(x) sp::LinesLength(x))
length_l_A <- sapply(methods::slot(l_A,"lines"), function(x) sp::LinesLength(x))
length_nnl <- sapply(methods::slot(nnl_sldf,"lines"), function(x) sp::LinesLength(x))
length_l_A <- sum(sapply(methods::slot(l_A,"lines"), function(x) sp::LinesLength(x)))
length_nnl <- sum(sapply(methods::slot(nnl_sldf,"lines"), function(x) sp::LinesLength(x)))
(length_l_A-length_nnl)/length_l_A
(length_nnl-length_l_A)/length_l_A
abs((length_nnl-length_l_A)/length_l_A)
round(abs((length_l_A-length_nnl)/length_l_A))
round(abs((length_l_A-length_nnl)/length_l_A)*100)
warning(writeLines("Difference between SpatialLine A length and SpatialLine nnl result length is upper than 20%",
"Segments length of Line B should be smaller than Segments length of Line A"))
writeLines("Difference between SpatialLine A length and SpatialLine nnl result length is upper than 20%",
"Segments length of Line B should be smaller than Segments length of Line A")
writeLines("Difference between SpatialLine A length and SpatialLine nnl result length is upper than 20%",
"Segments length of Line B should be smaller than Segments length of Line A")
riteLines("Difference between SpatialLine A length and SpatialLine nnl result length is upper than 20%"
writeLines("Difference between SpatialLine A length and SpatialLine nnl result length is upper than 20%"
)
writeLines(c("Difference between SpatialLine A length and SpatialLine nnl result length is upper than 20%",
"Segments length of Line B should be smaller than Segments length of Line A"))
warning(writeLines(c("Difference between SpatialLine A length and SpatialLine nnl result length is upper than 20%",
"Segments length of Line B should be smaller than Segments length of Line A")))
warnings(writeLines(c("Difference between SpatialLine A length and SpatialLine nnl result length is upper than 20%",
"Segments length of Line B should be smaller than Segments length of Line A")))
warnings("Difference between SpatialLine A length and SpatialLine nnl result length is upper than 20% \n
Segments length of Line B should be smaller than Segments length of Line A")
warning("Difference between SpatialLine A length and SpatialLine nnl result length is upper than 20% \n
Segments length of Line B should be smaller than Segments length of Line A")
warning("Difference between SpatialLine A length and SpatialLine nnl result length is upper than 20% \n Segments length of Line B should be smaller than Segments length of Line A")
arning(paste("Difference between SpatialLine A length and SpatialLine nnl result length is upper than 20%",
"Segments length of Line B should be smaller than Segments length of Line A", sep = "\n"))
warning(paste("Difference between SpatialLine A length and SpatialLine nnl result length is upper than 20%",
"Segments length of Line B should be smaller than Segments length of Line A", sep = "\n"))
arning(paste(paste("Difference between SpatialLine A length and SpatialLine nnl result length is upper than 20% :", diff_length),
"Segments length of Line B should be smaller than Segments length of Line A", sep = "\n"))
warning(paste(paste("Difference between SpatialLine A length and SpatialLine nnl result length is upper than 20% :", diff_length),
"Segments length of Line B should be smaller than Segments length of Line A", sep = "\n"))
diff_length <- round(abs((length_l_A-length_nnl)/length_l_A)*100)
warning(paste(paste("Difference between SpatialLine A length and SpatialLine nnl result length is upper than 20% :", diff_length),
"Segments length of Line B should be smaller than Segments length of Line A", sep = "\n"))
warning(paste(paste("Difference between SpatialLine A length and SpatialLine nnl result length is upper than 20% :", diff_length, "%"),
"Segments length of Line B should be smaller than Segments length of Line A", sep = "\n"))
#'
#' extrapolate_example <- nnl(l_A = example,
#'                            l_B = river_bresle,
#'                            id_l_A = "ID_EXAMPLE",
#'                            id_l_B = "CdEntiteHydrographique")
#'
#' plot(river_bresle, col = "blue")
#' plot(example, col = "green", add = T)
#' plot(extrapolate_example, col = "red", add = T )
#' }
nnl <- function(l_A, l_B, id_l_A, id_l_B, id_p_A = "ID_PTS_A", id_p_B = "ID_PTS_B", step = 5, rate = 45, p = T, ncores = NULL){
#test CRS comparaison
if(!raster::compareCRS(l_A, l_B)) stop("SpatialPointsDataFrames have not the same CRS")
#test projection info. objects should be in planar coordinates (cf sp::sample)
if(!is.projected(l_A) || !is.projected(l_B)) stop("objects should be in planar coordinates")
#create points along lines A
points_A <- create_pts(l = l_A, id_l = id_l_A, id_p = id_p_A, step = step, p = p, ncores = ncores)
#create points along lines B
points_B <- create_pts(l = l_B, id_l = id_l_B, id_p = id_p_B, step = step, p = p, ncores = ncores)
#find nearest points
np_points_A <- find_np(pts_A = points_A, pts_B = points_B , id_p_A = id_p_A, id_p_B = id_p_B, p = p, ncores = ncores)
#select nearest lines
np_step1 <- nnl_step1(pts_A = points_A,
pts_B = points_B,
fnp_A = np_points_A,
id_p_A = id_p_A,
id_p_B = id_p_B,
id_l_A = id_l_A,
id_l_B = id_l_B,
rate = rate)
#find discontinuities
np_step2 <- nnl_step2(l_B = l_B, r_s1_A = np_step1, id_l_B = id_l_B, id_l_A = id_l_A)
#select only columns with IDs of lines A and B on step 1
nnl_s1 <- np_step1[, c(id_l_A, id_l_B)]
#Idem on step 2
nnl_s2 <- np_step2[, c(id_l_A, id_l_B)]
#fuse dataframes
nnl_full <- rbind(nnl_s1, nnl_s2)
#Select nearest lines in lines B
nnl_sldf <- l_B[l_B@data[, id_l_B] %in% nnl_full[, id_l_B],]
#add lines A IDs to nearest lines B
nnl_sldf <- merge(nnl_sldf, nnl_full, by = id_l_B, all.x = T)
#calculate Line A total length
length_l_A <- sum(sapply(methods::slot(l_A,"lines"), function(x) sp::LinesLength(x)))
#calculate nnl result total length
length_nnl <- sum(sapply(methods::slot(nnl_sldf,"lines"), function(x) sp::LinesLength(x)))
#calculate difference
diff_length <- round(abs((length_l_A-length_nnl)/length_l_A)*100)
#Warning if difference is too hight
if(diff_length > 20) warning(paste(paste("Difference between SpatialLine A length and SpatialLine nnl result length is upper than 20% :", diff_length, "%"),
"Segments length of Line B should be smaller than Segments length of Line A", sep = "\n"))
#return Spatial
return(nnl_sldf)
}
extrapolate_example <- nnl(l_A = example,
l_B = river_bresle,
id_l_A = "ID_EXAMPLE",
id_l_B = "CdEntiteHydrographique")
warning(paste(paste("Difference between SpatialLine A length and SpatialLine nnl result length is upper than 20% :", diff_length, "%"),
"@lines length of SpatialLine B should be smaller than @lines length of SpatialLine A", sep = "\n"))
round(abs((1000000-10)/1000000)*100)
length_nnl/length_l_A
length_l_A/length_nnl
warning(paste(paste0("Difference between SpatialLine A length and SpatialLine nnl result length is upper than 20% : ", diff_length, "%"),
"@lines length of SpatialLine B should be smaller than @lines length of SpatialLine A", sep = "\n"))
