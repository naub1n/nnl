pts_B = POINTS_B,
fnp_A = np_POINTS_A,
id_p_A = "ID_PT_ME",
id_p_B = "ID_PT_TR",
id_l_A = "CdMasseDEa",
id_l_B = "ID", rate = 45)
plot(shp_me, col = "blue")
plot(shp_topo[shp_topo@data$ID %in% np_step1$ID,], add = T)
shp_topo <- readOGR("C:/Users/aubin_ni/Dropbox/Projet_Taux_Etagement_AESN/ARCHIVES/shapes/shp_tr_topo","TRONCON_TOPO_DSAv_coord_sans_doublons")
system.time({POINTS_B<-create_pts(l = shp_topo, id_l = "ID", id_p = "ID_PT_TR")})
np_POINTS_A <- find_np(POINTS_A, POINTS_B , id_p_A = "ID_PT_ME", id_p_B = "ID_PT_TR", p=F)
np_step1 <- nnl_step1(pts_A = POINTS_A,
pts_B = POINTS_B,
fnp_A = np_POINTS_A,
id_p_A = "ID_PT_ME",
id_p_B = "ID_PT_TR",
id_l_A = "CdMasseDEa",
id_l_B = "ID", rate = 45)
plot(shp_me, col = "blue")
plot(shp_topo[shp_topo@data$ID %in% np_step1$ID,], add = T)
# Extraction des coordonnées amont/aval des tronçons BD TOPO
Listcoordtr <- lapply(slot(shp_topo, "lines"), function(x) lapply(slot(x, "Lines"),
function(y) slot(y, "coords")))
NOEUDS_TOPO<-subset(shp_topo@data,select =("ID")) ### selection colonne par nom de champ
NOEUDS_TOPO$X_MIN<-as.numeric(lapply(Listcoordtr, function(x) x[[1]][1,1]))
NOEUDS_TOPO$Y_MIN<-as.numeric(lapply(Listcoordtr, function(x) x[[1]][1,2]))
NOEUDS_TOPO$X_MAX<-as.numeric(lapply(Listcoordtr, function(x) x[[length(x)]][nrow(x[[length(x)]]),1]))
NOEUDS_TOPO$Y_MAX<-as.numeric(lapply(Listcoordtr, function(x) x[[length(x)]][nrow(x[[length(x)]]),2]))
testa<-subset(NOEUDS_TOPO,select=c("ID","X_MIN","Y_MIN"))
testb<-subset(NOEUDS_TOPO,select=c("ID","X_MAX","Y_MAX"))
colnames(testb)[2:3]<-c("X","Y")
colnames(testa)[2:3]<-c("X","Y")
NOEUDS_TOPO<-rbind(testa,testb)
NOEUDS_TOPO$ID_NOEUD<-seq.int(nrow(NOEUDS_TOPO))
View(NOEUDS_TOPO)
#Jointure permettant de distinguer les tronçons identifiés sur le DP en phase 1
TRONCON<-merge(NOEUDS_TOPO,COMPTE_POINT,by.x = "ID",by.y = "ID_TR_TOPO",all.x = T, all.y = T)
View(NOEUDS_TOPO)
l=shp_topo
id_l = "ID"
lst_coord
#extract coordinates for each extremity of each line
lst_coord <- lapply(slot(l, "lines"), function(x) lapply(slot(x, "Lines"),
function(y) slot(y, "coords")))
nodes <- subset(shp_topo@data, select = id_l) ### selection colonne par nom de champ
View(nodes)
View(lst_coord)
COMPTE_POINT=POINTS_B
#Jointure permettant de distinguer les tronçons identifiés sur le DP en phase 1
TRONCON<-merge(NOEUDS_TOPO,COMPTE_POINT,by.x = "ID",by.y = "ID_TR_TOPO",all.x = T, all.y = T)
TRONCON<-merge(NOEUDS_TOPO,COMPTE_POINT,by.x = "ID",by.y = "ID_PT_TR",all.x = T, all.y = T)
View(TRONCON)
#Remplace les valeurs nulles du champ DP_phase1 par "non" // ATTENTION : as.character devant lapply, sinon le champs est de type list et ça bug dans les calcul de somme
TRONCON$DP_Phase1<-as.character(lapply(TRONCON$DP_Phase1,function(x) ifelse (is.na(x),"non",x)))
COMPTE_POINT=np_step1
TRONCON<-merge(NOEUDS_TOPO,COMPTE_POINT,by.x = "ID",by.y = "ID_PT_TR",all.x = T, all.y = T)
TRONCON<-merge(NOEUDS_TOPO,COMPTE_POINT,by.x = "ID",by.y = "ID",all.x = T, all.y = T)
View(TRONCON)
TRONCON$DP_Phase1<-as.character(lapply(TRONCON$SELECT_STEP1,function(x) ifelse (is.na(x),"non",x)))
View(TRONCON)
#Toilettage table jointure
TRONCON<-subset(TRONCON,select=c("CdMasseDEa","ID","ID_NOEUD","X","Y","DP_Phase1"))### 13/06 : Champ "ALTI" suppr
#Jointure sur les deux champs (X et Y)
RQT1<-merge(TRONCON,TRONCON,by.x=c("X","Y"),by.y=c("X","Y"))
#On ne garde que les lignes avec des ID Tronçon différents
RQT1<-subset(RQT1,RQT1$ID.x!=RQT1$ID.y)
#Affichage résultats RQT1
print(paste("RQT1 :",nrow(RQT1)))
#On garde l'info 'DP_Phase1.x' pour savoir si le tronçon étudié est selectionné ou non
RQT2<-ddply(RQT1,.(CdMasseDEa.x,ID.x,ID_NOEUD.x,DP_Phase1.x),
#Compte du nombre de tronçon selectionnés par couple Tronçon/Point
summarise, cptSelect=sum(DP_Phase1.y=="oui"))
#On garde l'info 'DP_Phase1.x' pour savoir si le tronçon étudié est selectionné ou non
RQT2<- plyr::ddply(RQT1,.(CdMasseDEa.x,ID.x,ID_NOEUD.x,DP_Phase1.x),
#Compte du nombre de tronçon selectionnés par couple Tronçon/Point
summarise, cptSelect=sum(DP_Phase1.y=="oui"))
#On garde l'info 'DP_Phase1.x' pour savoir si le tronçon étudié est selectionné ou non
RQT2<- plyr::ddply(RQT1,.(CdMasseDEa.x,ID.x,ID_NOEUD.x,DP_Phase1.x),
#Compte du nombre de tronçon selectionnés par couple Tronçon/Point
summarise, cptSelect=sum(DP_Phase1.y=="oui"))
#On garde l'info 'DP_Phase1.x' pour savoir si le tronçon étudié est selectionné ou non
RQT2<- ddply(RQT1, .(CdMasseDEa.x,ID.x,ID_NOEUD.x,DP_Phase1.x),
#Compte du nombre de tronçon selectionnés par couple Tronçon/Point
summarise, cptSelect=sum(DP_Phase1.y=="oui"))
#On garde l'info 'DP_Phase1.x' pour savoir si le tronçon étudié est selectionné ou non
RQT2<- plyr::ddply(RQT1, .(CdMasseDEa.x,ID.x,ID_NOEUD.x,DP_Phase1.x),
#Compte du nombre de tronçon selectionnés par couple Tronçon/Point
summarise, cptSelect=sum(DP_Phase1.y=="oui"))
RQT2<-plyr::ddply(RQT1,.(CdMasseDEa,ID,ID_NODE,SELECT_STEP1),
#Compte du nombre de tronçon selectionnés par couple Tronçon/Point
summarise, cptSelect=sum(SELECT_STEP1.y=="oui"))
RQT2<-plyr::ddply(RQT1,.(CdMasseDEa,ID,ID_NODE,SELECT_STEP1),
#Compte du nombre de tronçon selectionnés par couple Tronçon/Point
summarise, cptSelect=sum(SELECT_STEP1=="oui"))
View(TRONCON)
l_B = l
r_s1_A = np_step1
id_l_A = "CdMasseDEa"
id_l_B = "ID"
#extract points coordinates of each line
lst_coord <- lapply(slot(l_B, "lines"), function(x) lapply(slot(x, "Lines"), function(y) slot(y, "coords")))
#create IDs vector
nodes <- subset(l_B@data, select = id_l_B)
#extract extremities coordinates of each lines
nodes$X_MIN <- as.numeric(lapply(lst_coord, function(x) x[[1]][1,1]))
nodes$Y_MIN <- as.numeric(lapply(lst_coord, function(x) x[[1]][1,2]))
nodes$X_MAX <- as.numeric(lapply(lst_coord, function(x) x[[length(x)]][nrow(x[[length(x)]]),1]))
nodes$Y_MAX <- as.numeric(lapply(lst_coord, function(x) x[[length(x)]][nrow(x[[length(x)]]),2]))
#create dataframe with lower extremities
nodes_min <- subset(nodes, select=c("ID","X_MIN","Y_MIN"))
#create dataframe with upper extremities
nodes_max <- subset(nodes,select=c("ID","X_MAX","Y_MAX"))
#rename columns
colnames(nodes_min)[2:3]<-c("X","Y")
colnames(nodes_max)[2:3]<-c("X","Y")
#merge dataframes
nodes.full <- rbind(nodes_min,nodes_max)
#add ID for each node
nodes.full$ID_NODE <- seq.int(nrow(nodes.full))
#Jointure permettant de distinguer les tronçons identifiés sur le DP en phase 1
nodes.nnlstep1 <- merge(nodes.full, r_s1_A, by = id_l_B, all.x = T, all.y = T)
#Remplace les valeurs nulles du champ DP_phase1 par "non" // ATTENTION : as.character devant lapply, sinon le champs est de type list et ça bug dans les calcul de somme
nodes.nnlstep1$SELECT_STEP1 <- as.character(lapply(nodes.nnlstep1$SELECT_STEP1,function(x) ifelse (is.na(x),FALSE,x)))
#Toilettage table jointure
nodes.nnlstep1 <- subset(nodes.nnlstep1, select=c(id_l_A, id_l_B, "ID_NODE","X","Y","SELECT_STEP1"))
#Affichage Nombre Noeuds
print(paste("Nombre de TRONCON :",nrow(nodes.nnlstep1)))
# Extraction des coordonnées amont/aval des tronçons BD TOPO
Listcoordtr <- lapply(slot(shp_topo, "lines"), function(x) lapply(slot(x, "Lines"),
function(y) slot(y, "coords")))
NOEUDS_TOPO<-subset(shp_topo@data,select =("ID")) ### selection colonne par nom de champ
NOEUDS_TOPO$X_MIN<-as.numeric(lapply(Listcoordtr, function(x) x[[1]][1,1]))
NOEUDS_TOPO$Y_MIN<-as.numeric(lapply(Listcoordtr, function(x) x[[1]][1,2]))
NOEUDS_TOPO$X_MAX<-as.numeric(lapply(Listcoordtr, function(x) x[[length(x)]][nrow(x[[length(x)]]),1]))
NOEUDS_TOPO$Y_MAX<-as.numeric(lapply(Listcoordtr, function(x) x[[length(x)]][nrow(x[[length(x)]]),2]))
testa<-subset(NOEUDS_TOPO,select=c("ID","X_MIN","Y_MIN"))
testb<-subset(NOEUDS_TOPO,select=c("ID","X_MAX","Y_MAX"))
colnames(testb)[2:3]<-c("X","Y")
colnames(testa)[2:3]<-c("X","Y")
NOEUDS_TOPO<-rbind(testa,testb)
NOEUDS_TOPO$ID_NOEUD<-seq.int(nrow(NOEUDS_TOPO))
#Extraction des altitudes au droit des noeuds
coordinates(NOEUDS_TOPO) <- c("X", "Y")
#Jointure permettant de distinguer les tronçons identifiés sur le DP en phase 1
TRONCON<-merge(NOEUDS_TOPO,COMPTE_POINT,by.x = "ID",by.y = "ID_TR_TOPO",all.x = T, all.y = T)
TRONCON<-merge(NOEUDS_TOPO,COMPTE_POINT,by= "ID",all.x = T, all.y = T)
#Remplace les valeurs nulles du champ DP_phase1 par "non" // ATTENTION : as.character devant lapply, sinon le champs est de type list et ça bug dans les calcul de somme
TRONCON$DP_Phase1<-as.character(lapply(TRONCON$DP_Phase1,function(x) ifelse (is.na(x),"non",x)))
TRONCON$SELECT_STEP1<-as.character(lapply(TRONCON$SELECT_STEP1,function(x) ifelse (is.na(x),"non",x)))
#Toilettage table jointure
TRONCON<-subset(TRONCON,select=c("CdMasseDEa","ID","ID_NOEUD","X","Y","DP_Phase1"))### 13/06 : Champ "ALTI" suppr
#Affichage Nombre Noeuds
print(paste("Nombre de TRONCON :",nrow(TRONCON)))
#Jointure sur les deux champs (X et Y)
RQT1<-merge(nodes.nnlstep1, nodes.nnlstep1, by.x=c("X","Y"), by.y=c("X","Y"))
#Jointure sur les deux champs (X et Y)
RQT1<-merge(nodes.nnlstep1, nodes.nnlstep1, by=c("X","Y"))
View(RQT1)
#On garde l'info 'DP_Phase1.x' pour savoir si le tronçon étudié est selectionné ou non
RQT2<-ddply(RQT1,.(CdMasseDEa.x,ID.x,ID_NOEUD.x,DP_Phase1.x),
#Compte du nombre de tronçon selectionnés par couple Tronçon/Point
summarise, cptSelect=sum(DP_Phase1.y=="oui"))
#On garde l'info 'DP_Phase1.x' pour savoir si le tronçon étudié est selectionné ou non
RQT2<-plyr::ddply(RQT1,.(CdMasseDEa.x,ID.x,ID_NOEUD.x,DP_Phase1.x),
#Compte du nombre de tronçon selectionnés par couple Tronçon/Point
summarise, cptSelect=sum(DP_Phase1.y=="oui"))
RQT2 <- plyr::ddply(RQT1,
.("CdMasseDEa.x","ID.x","ID_NOEUD.x","DP_Phase1.x"),
.fun = function(x) plyr::summarise(x, cptSelect = sum(x[,colname] == TRUE)),
colname = "SELECT_STEP1.y")
RQT2 <- plyr::ddply(RQT1,
c("CdMasseDEa.x","ID.x","ID_NOEUD.x","DP_Phase1.x"),
.fun = function(x) plyr::summarise(x, cptSelect = sum(x[,colname] == TRUE)),
colname = "SELECT_STEP1.y")
RQT2 <- plyr::ddply(RQT1,
c("CdMasseDEa.x","ID.x","ID_NODE.x","DP_Phase1.x"),
.fun = function(x) plyr::summarise(x, cptSelect = sum(x[,colname] == TRUE)),
colname = "SELECT_STEP1.y")
RQT2 <- plyr::ddply(RQT1,
c("CdMasseDEa.x","ID.x","ID_NODE.x","SELECT_STEP1.x"),
.fun = function(x) plyr::summarise(x, cptSelect = sum(x[,colname] == TRUE)),
colname = "SELECT_STEP1.y")
RQT2 <- plyr::ddply(RQT1,
c("CdMasseDEa.x","ID.x","ID_NODE.x","SELECT_STEP1.x"),
.fun = function(x, colname) plyr::summarise(x, cptSelect = sum(x[,colname] == TRUE)),
colname = "SELECT_STEP1.y")
View(RQT2)
View(RQT1)
#exclude pairs with the same line ID
RQT1 <- subset(RQT1, RQT1$ID.x != RQT1$ID.y)
RQT2 <- plyr::ddply(RQT1,
c("CdMasseDEa.x","ID.x","ID_NODE.x","SELECT_STEP1.x"),
.fun = function(x, colname) plyr::summarise(x, cptSelect = sum(x[,colname] == TRUE)),
colname = "SELECT_STEP1.y")
View(RQT2)
View(RQT1)
View(RQT2)
RQT3<-plyr::ddply(RQT2,c(paste0(id_l_A,".x"), paste0(id_l_B,".x"), "SELECT_STEP1.x"),summarize ,
#Le nombre de points rattachés
CptPoint=length(ID_NOEUD.x),
#L'écart type du nombre de tronçons rattachés selectionnés
EcarTypeSelect=sd(cptSelect),
#La moyenne du nombre de tronçons rattachés selectionnés
MoySelect=mean(cptSelect))
RQT3<-plyr::ddply(RQT2,c(paste0(id_l_A,".x"), paste0(id_l_B,".x"), "SELECT_STEP1.x"),summarise ,
#Le nombre de points rattachés
CptPoint=length(ID_NOEUD.x),
#L'écart type du nombre de tronçons rattachés selectionnés
EcarTypeSelect=sd(cptSelect),
#La moyenne du nombre de tronçons rattachés selectionnés
MoySelect=mean(cptSelect))
RQT3<-plyr::ddply(RQT2,c(paste0(id_l_A,".x"), paste0(id_l_B,".x"), "SELECT_STEP1.x"), plyr::summarise ,
#Le nombre de points rattachés
CptPoint=length(ID_NOEUD.x),
#L'écart type du nombre de tronçons rattachés selectionnés
EcarTypeSelect=sd(cptSelect),
#La moyenne du nombre de tronçons rattachés selectionnés
MoySelect=mean(cptSelect))
RQT3<-plyr::ddply(RQT2,c(paste0(id_l_A,".x"), paste0(id_l_B,".x"), "SELECT_STEP1.x"), plyr::summarise ,
#Le nombre de points rattachés
CptPoint=length(ID_NODE.x),
#L'écart type du nombre de tronçons rattachés selectionnés
EcarTypeSelect=sd(NB_LINE_SELECT_STEP1),
#La moyenne du nombre de tronçons rattachés selectionnés
MoySelect=mean(NB_LINE_SELECT_STEP1))
#count number of lines selected in nnl_step1 for each line
RQT2 <- plyr::ddply(RQT1,
c(paste0(id_l_A,".x"), paste0(id_l_B,".x"), "ID_NODE.x", "SELECT_STEP1.x"),
.fun = function(x, colname) plyr::summarise(x, NB_LINE_SELECT_STEP1 = sum(x[,colname] == TRUE)),
colname = "SELECT_STEP1.y")
RQT3<-plyr::ddply(RQT2,c(paste0(id_l_A,".x"), paste0(id_l_B,".x"), "SELECT_STEP1.x"), plyr::summarise ,
#Le nombre de points rattachés
CptPoint=length(ID_NODE.x),
#L'écart type du nombre de tronçons rattachés selectionnés
EcarTypeSelect=sd(NB_LINE_SELECT_STEP1),
#La moyenne du nombre de tronçons rattachés selectionnés
MoySelect=mean(NB_LINE_SELECT_STEP1))
View(RQT3)
View(RQT2)
View(RQT1)
View(nodes)
View(nodes.full)
sd(c(1,2))
#identify discontinuities
RQT3$Disc<-ifelse(
#lines not selected at origin
RQT3$SELECT_STEP1.x == FALSE &
#wich have one line at each extremity (so 2 lines)
RQT3$NB_NODES == 2 &
#where there are as many lines at each extremity
RQT3$SD_LINES_SELECTED == 0 &
#to select only in case where there are 1 line selected at extremity and 1 line selected at other extremity
RQT3$MEAN_LINES_SELECTED == 1
,TRUE,FALSE)
ifelse(
#lines not selected at origin
RQT3$SELECT_STEP1.x == FALSE &
#wich have one line at each extremity (so 2 lines)
RQT3$NB_NODES == 2 &
#where there are as many lines at each extremity
RQT3$SD_LINES_SELECTED == 0 &
#to select only in case where there are 1 line selected at extremity and 1 line selected at other extremity
RQT3$MEAN_LINES_SELECTED == 1
,TRUE,FALSE)
RQT3$SELECT_STEP1.x == FALSE
RQT3$NB_NODES == 2
#statistics of each line
RQT3<-plyr::ddply(RQT2,c(paste0(id_l_A,".x"), paste0(id_l_B,".x"), "SELECT_STEP1.x"), plyr::summarise ,
#number of nodes
NB_NODES =length(ID_NODE.x),
#standard deviation of number of points for each extremity
SD_LINES_SELECTED = sd(NB_LINE_SELECT_STEP1),
#Mean of number of points for each extremity
MEAN_LINES_SELECTED=mean(NB_LINE_SELECT_STEP1))
# create classes
RQT3$classe<-ifelse(RQT3$NB_NODES == 2 & RQT3$MEAN_LINES_SELECTED == 0.5 & RQT3$SD_LINES_SELECTED == sd(c(1,2)),"1.0",
ifelse(RQT3$NB_NODES == 2 & RQT3$MEAN_LINES_SELECTED == 1 & RQT3$SD_LINES_SELECTED == 0,"1.1",
ifelse(RQT3$NB_NODES == 2 & RQT3$MEAN_LINES_SELECTED == 1 & RQT3$SD_LINES_SELECTED == 1,"2.0",
ifelse (RQT3$NB_NODES == 2 & RQT3$MEAN_LINES_SELECTED == 1.5 & RQT3$SD_LINES_SELECTED == sd(c(1,2)),"2.1",
ifelse (RQT3$NB_NODES == 2 & RQT3$MEAN_LINES_SELECTED == 2 & RQT3$SD_LINES_SELECTED == 0,"2.2",
"OTHER")))))
#identify discontinuities
RQT3$Disc<-ifelse(
#lines not selected at origin
RQT3$SELECT_STEP1.x == FALSE &
#wich have one line at each extremity (so 2 lines)
RQT3$NB_NODES == 2 &
#where there are as many lines at each extremity
RQT3$SD_LINES_SELECTED == 0 &
#to select only in case where there are 1 line selected at extremity and 1 line selected at other extremity
RQT3$MEAN_LINES_SELECTED == 1
,TRUE,FALSE)
View(RQT3)
#select only discontinuities
disc <- subset(RQT3,RQT3$Disc == TRUE)
colnames(RQT3)[grep(paste0(id_l_A,".x"),colnames(RQT3))] <- id_l_A
colnames(RQT3)[grep(paste0(id_l_B,".x"),colnames(RQT3))] <- id_l_B
RQT3<-plyr::ddply(RQT2,c(paste0(id_l_A,".x"), paste0(id_l_B,".x"), "SELECT_STEP1.x"), plyr::summarise ,
#number of nodes
NB_NODES =length(ID_NODE.x),
#standard deviation of number of points for each extremity
SD_LINES_SELECTED = sd(NB_LINE_SELECT_STEP1),
#Mean of number of points for each extremity
MEAN_LINES_SELECTED=mean(NB_LINE_SELECT_STEP1))
# create classes
RQT3$classe<-ifelse(RQT3$NB_NODES == 2 & RQT3$MEAN_LINES_SELECTED == 0.5 & RQT3$SD_LINES_SELECTED == sd(c(1,2)),"1.0",
ifelse(RQT3$NB_NODES == 2 & RQT3$MEAN_LINES_SELECTED == 1 & RQT3$SD_LINES_SELECTED == 0,"1.1",
ifelse(RQT3$NB_NODES == 2 & RQT3$MEAN_LINES_SELECTED == 1 & RQT3$SD_LINES_SELECTED == 1,"2.0",
ifelse (RQT3$NB_NODES == 2 & RQT3$MEAN_LINES_SELECTED == 1.5 & RQT3$SD_LINES_SELECTED == sd(c(1,2)),"2.1",
ifelse (RQT3$NB_NODES == 2 & RQT3$MEAN_LINES_SELECTED == 2 & RQT3$SD_LINES_SELECTED == 0,"2.2",
"OTHER")))))
#identify discontinuities
RQT3$Disc<-ifelse(
#lines not selected at origin
RQT3$SELECT_STEP1.x == FALSE &
#wich have one line at each extremity (so 2 lines)
RQT3$NB_NODES == 2 &
#where there are as many lines at each extremity
RQT3$SD_LINES_SELECTED == 0 &
#to select only in case where there are 1 line selected at extremity and 1 line selected at other extremity
RQT3$MEAN_LINES_SELECTED == 1
,TRUE,FALSE)
disc <- subset(RQT3,RQT3$Disc == TRUE)
colnames(disc)[grep(paste0(id_l_A,".x"),colnames(disc))] <- id_l_A
colnames(disc)[grep(paste0(id_l_B,".x"),colnames(disc))] <- id_l_B
View(disc)
View(disc)
TBL_FIN.1<-subset(COMPTE_POINT,select=c("CdMasseDEa","ID_TR_TOPO"))
View(COMPTE_POINT)
View(np_POINTS_A)
View(nodes.nnlstep1)
View(RQT1)
View(disc)
#find line A ID for each line B
RQT1[RQT1[,"ID.x"] == "TRON_EAU0000000039116499", "CdMasseDEa.y"]
#find line A ID for each line B
unique(RQT1[RQT1[,"ID.x"] == "TRON_EAU0000000039116499", "CdMasseDEa.y"])
View(disc)
#find line A ID for each line B
disc[, id_l_A] <- apply(disc, 1, function(x) unique(RQT1[RQT1[,"ID.x"] == x[id_l_B], "CdMasseDEa.y"]))
apply(disc, 1, function(x) unique(RQT1[RQT1[,"ID.x"] == x[id_l_B], "CdMasseDEa.y"]))
test = apply(disc, 1, function(x) unique(RQT1[RQT1[,"ID.x"] == x[id_l_B], "CdMasseDEa.y"]))
View(test)
#find line A ID for each line B
disc[, id_l_A] <- apply(disc, 1, function(x) unique(RQT1[RQT1[,"ID.x"] == x[id_l_B] & RQT1$SELECT_STEP1.y , "CdMasseDEa.y"]))
test = apply(disc, 1, function(x) unique(RQT1[RQT1[,"ID.x"] == x[id_l_B] & RQT1$SELECT_STEP1.y , "CdMasseDEa.y"]))
RQT1$SELECT_STEP1.y
RQT1[,"ID.x"] == x[id_l_B]
test = apply(disc, 1, function(x) unique(RQT1[RQT1[,"ID.x"] == x[id_l_B] && RQT1$SELECT_STEP1.y , "CdMasseDEa.y"]))
View(test)
View(test)
#find line A ID for each line B
disc[, id_l_A] <- apply(disc, 1, function(x) unique(RQT1[RQT1[,"ID.x"] == x[id_l_B] & RQT1$SELECT_STEP1.y , "CdMasseDEa.y"]))
#find line A ID for each line B
disc[, id_l_A] <- apply(disc, 1, function(x) unique(RQT1[RQT1[,"ID.x"] == x[id_l_B] && RQT1$SELECT_STEP1.y , "CdMasseDEa.y"]))
View(disc)
#select only discontinuities
disc <- subset(RQT3, RQT3$Disc == TRUE)
#rename columns
colnames(disc)[grep(paste0(id_l_A,".x"), colnames(disc))] <- id_l_A
colnames(disc)[grep(paste0(id_l_B,".x"), colnames(disc))] <- id_l_B
View(disc)
apply(disc, 1, function(x) unique(RQT1[RQT1[,"ID.x"] == x[id_l_B] && RQT1$SELECT_STEP1.y , "CdMasseDEa.y"]))
as.character(apply(disc, 1, function(x) unique(RQT1[RQT1[,"ID.x"] == x[id_l_B] && RQT1$SELECT_STEP1.y , "CdMasseDEa.y"])))
apply(disc, 1, function(x) as.character(unique(RQT1[RQT1[,"ID.x"] == x[id_l_B] && RQT1$SELECT_STEP1.y , "CdMasseDEa.y"])))
unique(RQT1[RQT1[,"ID.x"] == "TRON_EAU0000000039116507" && RQT1$SELECT_STEP1.y , "CdMasseDEa.y"])
unique(RQT1[RQT1[,"ID.x"] == "TRON_EAU0000000039116507" & RQT1$SELECT_STEP1.y == TRUE , "CdMasseDEa.y"])
#find line A ID for each line B
disc[, id_l_A] <- apply(disc, 1, function(x) unique(RQT1[RQT1[,"ID.x"] == x[id_l_B] && RQT1$SELECT_STEP1.y == TRUE , "CdMasseDEa.y"]))
View(disc)
#find line A ID for each line B
disc[, id_l_A] <- apply(disc, 1, function(x) unique(RQT1[RQT1[,"ID.x"] == x[id_l_B] & RQT1$SELECT_STEP1.y == TRUE , "CdMasseDEa.y"]))
#find line A ID for each line B
disc[, id_l_A] <- apply(disc, 1, function(x) {
id <- unique(RQT1[RQT1[,"ID.x"] == x[id_l_B] & RQT1$SELECT_STEP1.y == TRUE , "CdMasseDEa.y"])
id.f <- ifelse(length(id) == 1, id, NA)
return(id.f)
})
View(disc)
View(disc)
#find line A ID for each line B
disc[, id_l_A] <- apply(disc, 1, function(x) {
id <- unique(RQT1[RQT1[,"ID.x"] == x[id_l_B] & RQT1$SELECT_STEP1.y == TRUE , "CdMasseDEa.y"])
id.f <- ifelse(length(id) == 1, id, NA)
return(id)
})
View(disc)
#find line A ID for each line B
disc[, id_l_A] <- apply(disc, 1, function(x) {
id <- unique(RQT1[RQT1[,"ID.x"] == x[id_l_B] & RQT1$SELECT_STEP1.y == TRUE , "CdMasseDEa.y"])
id.f <- ifelse(length(id) == 1, id, NA)
writeLines(id.f)
return(id.f)
})
#find line A ID for each line B
disc[, id_l_A] <- apply(disc, 1, function(x) {
id <- unique(RQT1[RQT1[,"ID.x"] == x[id_l_B] & RQT1$SELECT_STEP1.y == TRUE , "CdMasseDEa.y"])
id.f <- ifelse(length(id) == 1, id, NA)
writeLines(as.character(id.f))
return(id.f)
})
id <- unique(RQT1[RQT1[,"ID.x"] == "TRON_EAU0000000039116499" & RQT1$SELECT_STEP1.y == TRUE , "CdMasseDEa.y"])
ifelse(length(id) == 1, id, NA)
id
length(id)
length(id) == 1
id
ifelse(length(id) == 0, id, NA)
ifelse(length(id) == 1, id, NA)
id.f <- if(length(id) == 1) id else NA)
id.f <- if(length(id) == 1) id else NA
#find line A ID for each line B
disc[, id_l_A] <- apply(disc, 1, function(x) {
id <- unique(RQT1[RQT1[,"ID.x"] == x[id_l_B] & RQT1$SELECT_STEP1.y == TRUE , "CdMasseDEa.y"])
id.f <- if(length(id) == 1) id else NA
writeLines(as.character(id.f))
return(id.f)
})
nnl_step2 <- function(l_B, r_s1_A, id_l_A, id_l_B){
#extract points coordinates of each line
lst_coord <- lapply(slot(l_B, "lines"), function(x) lapply(slot(x, "Lines"), function(y) slot(y, "coords")))
#create IDs vector
nodes <- subset(l_B@data, select = id_l_B)
#extract extremities coordinates of each lines
nodes$X_MIN <- as.numeric(lapply(lst_coord, function(x) x[[1]][1,1]))
nodes$Y_MIN <- as.numeric(lapply(lst_coord, function(x) x[[1]][1,2]))
nodes$X_MAX <- as.numeric(lapply(lst_coord, function(x) x[[length(x)]][nrow(x[[length(x)]]),1]))
nodes$Y_MAX <- as.numeric(lapply(lst_coord, function(x) x[[length(x)]][nrow(x[[length(x)]]),2]))
#create dataframe with lower extremities
nodes_min <- subset(nodes, select=c("ID","X_MIN","Y_MIN"))
#create dataframe with upper extremities
nodes_max <- subset(nodes,select=c("ID","X_MAX","Y_MAX"))
#rename columns
colnames(nodes_min)[2:3]<-c("X","Y")
colnames(nodes_max)[2:3]<-c("X","Y")
#merge dataframes
nodes.full <- rbind(nodes_min,nodes_max)
#add ID for each node
nodes.full$ID_NODE <- seq.int(nrow(nodes.full))
#Jointure permettant de distinguer les tronçons identifiés sur le DP en phase 1
nodes.nnlstep1 <- merge(nodes.full, r_s1_A, by = id_l_B, all.x = T, all.y = T)
#Remplace les valeurs nulles du champ DP_phase1 par "non" // ATTENTION : as.character devant lapply, sinon le champs est de type list et ça bug dans les calcul de somme
nodes.nnlstep1$SELECT_STEP1 <- as.character(lapply(nodes.nnlstep1$SELECT_STEP1,function(x) ifelse (is.na(x),FALSE,x)))
#Toilettage table jointure
nodes.nnlstep1 <- subset(nodes.nnlstep1, select=c(id_l_A, id_l_B, "ID_NODE","X","Y","SELECT_STEP1"))
#Affichage Nombre Noeuds
print(paste("Nombre de TRONCON :",nrow(nodes.nnlstep1)))
#merge nodes with themselves to find neighbour of each line
RQT1 <- merge(nodes.nnlstep1, nodes.nnlstep1, by=c("X","Y"))
#exclude pairs with the same line ID
RQT1 <- subset(RQT1, RQT1$ID.x != RQT1$ID.y)
#count number of lines selected in nnl_step1 for each node
RQT2 <- plyr::ddply(RQT1,
c(paste0(id_l_A,".x"), paste0(id_l_B,".x"), "ID_NODE.x", "SELECT_STEP1.x"),
.fun = function(x, colname) plyr::summarise(x, NB_LINE_SELECT_STEP1 = sum(x[,colname] == TRUE)),
colname = "SELECT_STEP1.y")
#statistics of each line
RQT3<-plyr::ddply(RQT2,c(paste0(id_l_A,".x"), paste0(id_l_B,".x"), "SELECT_STEP1.x"), plyr::summarise ,
#number of nodes
NB_NODES =length(ID_NODE.x),
#standard deviation of number of points for each extremity
SD_LINES_SELECTED = sd(NB_LINE_SELECT_STEP1),
#Mean of number of points for each extremity
MEAN_LINES_SELECTED=mean(NB_LINE_SELECT_STEP1))
# create classes
RQT3$classe<-ifelse(RQT3$NB_NODES == 2 & RQT3$MEAN_LINES_SELECTED == 0.5 & RQT3$SD_LINES_SELECTED == sd(c(1,2)),"1.0",
ifelse(RQT3$NB_NODES == 2 & RQT3$MEAN_LINES_SELECTED == 1 & RQT3$SD_LINES_SELECTED == 0,"1.1",
ifelse(RQT3$NB_NODES == 2 & RQT3$MEAN_LINES_SELECTED == 1 & RQT3$SD_LINES_SELECTED == 1,"2.0",
ifelse (RQT3$NB_NODES == 2 & RQT3$MEAN_LINES_SELECTED == 1.5 & RQT3$SD_LINES_SELECTED == sd(c(1,2)),"2.1",
ifelse (RQT3$NB_NODES == 2 & RQT3$MEAN_LINES_SELECTED == 2 & RQT3$SD_LINES_SELECTED == 0,"2.2",
"OTHER")))))
#identify discontinuities
RQT3$Disc<-ifelse(
#lines not selected at origin
RQT3$SELECT_STEP1.x == FALSE &
#wich have one line at each extremity (so 2 lines)
RQT3$NB_NODES == 2 &
#where there are as many lines at each extremity
RQT3$SD_LINES_SELECTED == 0 &
#to select only in case where there are 1 line selected at extremity and 1 line selected at other extremity
RQT3$MEAN_LINES_SELECTED == 1
,TRUE,FALSE)
#select only discontinuities
disc <- subset(RQT3, RQT3$Disc == TRUE)
#rename columns
colnames(disc)[grep(paste0(id_l_A,".x"), colnames(disc))] <- id_l_A
colnames(disc)[grep(paste0(id_l_B,".x"), colnames(disc))] <- id_l_B
#find line A ID for each line B
disc[, id_l_A] <- apply(disc, 1, function(x) {
id <- unique(RQT1[RQT1[,"ID.x"] == x[id_l_B] & RQT1$SELECT_STEP1.y == TRUE , "CdMasseDEa.y"])
#return NA if many IDs are found
id.f <- if(length(id) == 1) id else NA
return(id.f)
})
#return result
return(disc)
}
np_step2 <- nnl_step2(l_B = shp_topo,
r_s1_A = np_step1,
id_l_B = "ID",
id_l_A = "CdMasseDEa")
View(np_step2)
install.packages("roxygen2")
install.packages("SearchTrees")
install.packages("data.table")
install.packages("knitr")
install.packages("rmarkdown")
install.packages("tinytex")
install.packages("tools")
install.packages("tools")
install.packages("tools")
install.packages("tools")
